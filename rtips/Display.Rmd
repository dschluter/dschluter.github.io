---
title: "Graphs and Tables"
author:

<!--  output: html_document -->
output:
  html_document:
    toc: true
    toc_depth: 3
    toc_float: 
      collapsed: false
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

This page provides tips and recommendations for making graphs and tables in R.

In the examples below, <code>x</code> and <code>y</code> are numeric variables in the data frame, <code>mydata</code>. <code>A</code> and <code>B</code> are categorical variables (factors or character variables) identifying different groups.

We include examples making use of the add-on packages <code>dplyr</code> and <code>ggplot2</code>. Hadley Wickham's book is the standard reference (Wickam, H. 2016. *ggplot2: Elegant graphics for data analysis. 2nd edition*) but plenty of introductory resources are available online (e.g., <a href="http://r-statistics.co/ggplot2-Tutorial-With-R.html">this one</a>).

Run the <code>theme_set(theme_classic())</code> command at the start of your session to replace <code>ggplot2</code>'s default theme, which has too much chartjunk. Or, add the theme ```+ theme_classic()``` to your ```ggplot()``` command. Other simple themes include <code>theme_minimal()</code> and <code>theme_bw()</code>. 

```{r eval = FALSE}
library(dplyr)
library(ggplot2)
theme_set(theme_classic())
```

***

## Frequency tables
These commands generate tables of frequencies.

<br>

### One categorical variable
This frequency table counts the number (frequency) of cases in each category of a categorical variable <code>A</code>. Using the <code>useNA</code> argument add the category <code>NA</code> if one or more cases is missing.

```{r eval = FALSE}
table(mydata$A, useNA = "ifany")
# or
with(mydata, table(A), useNA = "ifany")
```

The <code>summarize</code> command in <code>dplyr</code> package can generate frequency tables with its <code>n()</code> function.

```{r eval = FALSE}
summarize(group_by(mydata, A), Frequency = n())
```

<br>

### Two variables (contingency table)
The following commands generate a frequency table for two categorical variables, <code>A</code> and <code>B</code>. The command can be extended to three or more variables.

```{r eval = FALSE}
table(mydata$A, mydata$B, useNA = "ifany")
```

To include the row and column sums, use

```{r eval = FALSE}
mytab <- table(mydata$A, mydata$B)
addmargins(mytab, margin = c(1,2), FUN = sum, quiet = TRUE)
```

The same thing can be accomplished with <code>dplyr</code>, except zero counts are given as NA.

```{r eval = FALSE}
spread( summarize(group_by(mydata, A, B), n = n()), B, n )
```

<br>

### Flat frequency table
The following commands generate a "flat" frequency table for two categorical variables, <code>A</code> and <code>B</code>. In a flat table, <code>A</code> and <code>B</code> are separate columns of a table, and a third column tallies the frequencies of each combination. The table will show a count of 0 for category combinations not present in the data.

```{r eval = FALSE}
mytab <- table(Aname = mydata$A, Bname = mydata$B)
data.frame(mytab, stringsasFactors = FALSE)
# or
data.frame(ftable(mydata[, c("A","B")], row.vars = c("A","B")))
```

The <code>summarize</code> method of <code>dplyr</code> will tally only the combinations of categories that have a frequency greater than 0. Hence, <code>ftable</code> is preferred. Alternatively, a fix is available in the <code>tidyr</code> package (you might need to install first):

```{r eval = FALSE}
library(tidyr)
mytab <- summarize(group_by(mydata, A, B), freq = n())
complete(ungroup(mytab), A, B, fill = list(freq = 0))
```

***

## Tables of descriptive statistics
The <code>tapply</code> command creates tables of descriptive statistics by group (e.g., mean, standard deviation, median, etc). So does the <code>summarize</code> command of the <code>dplyr</code> package, as shown here.

<br>

### One categorical variable
Here is how to generate a table of group means for a variable <code>y</code>, where <code>A</code> is the categorical grouping variable.

```{r eval = FALSE}
# result is a vector
tapply(mydata$y, INDEX = mydata$A, FUN = mean, na.rm = TRUE)

# dplyr method; result is a data frame
summarize(group_by(mydata, A), ybar = mean(y, na.rm = TRUE)) 
```

The argument <code>na.rm = TRUE</code> removes missing values (otherwise the mean returns <code>NA</code> if missing values are present). With <code>tapply</code>, pass optional arguments to <code>FUN</code> by including them immediately afterward.

The <code>dplyr</code> can calculate more than one descriptive statistic at once. Here we calculate mean, standard deviation, and number of observations (including missing observations) for the variable <code>x</code> by group.

```{r eval = FALSE}
summarize(group_by(mydata, A), xbar = mean(x, na.rm = TRUE),
              s = sd(x, na.rm = TRUE), n = n()) 
```

<br>

### More than one categorical variable
To calculate descriptive statistics (e.g., the median of <code>x</code>) with more than one grouping variable, use one of the following commands.

```{r eval = FALSE}
# dplyr command, yields a data frame
summarize(group_by(mydata, A, B), ybar = median(y, na.rm = TRUE))

# yields a data frame
aggregate(mydata$y, by = list(A = mydata$A, B = mydata$B), FUN = median) 

# yields a r x c matrix
tapply(mydata$y, INDEX = list(mydata$A, mydata$B), FUN = median)
```

<br>

### More than one response variable
The <code>dplyr</code> method allows you to tabulate summaries for more than one variable. 

For example, if your data frame <code>mydata</code> contains a categorical variable named <code>A</code> that has multiple categories, you can obtained means and standard deviations by group for one (or more) numeric variables <code>y1</code>, <code>y2</code>, etc, as follows. Result can be saved as a new data frame (here, named <code>z</code>).

```{r eval = FALSE}
z <- summarize(group_by(mydata, A), 
               mean1 = mean(y1, na.rm = TRUE),
               mean2 = mean(y2, na.rm = TRUE),
               mean3 = mean(y3, na.rm = TRUE),
               sd1 = sd(y1, na.rm = TRUE),
               sd2 = sd(y2, na.rm = TRUE),
               sd3 = sd(y3, na.rm = TRUE))
print(z)
```

***

## Drawing graphs in R
A graph displays a frequency distributions of a variable (e.g., histogram, bar graphs), the association between two (or more) variables, and differences between groups.

<br>

### Command options for base R plots
Many (but not all -- try them) of the basic plotting commands in base R will accept the same arguments to control axis limits, labeling, and other options. If you are not sure whether a given option works in your case, try it. The worst that could happen is you get an error message, or R ignores you.

```{r eval = FALSE}
main = "Eureka"    # add a title above the graph
pch = 16           # set plot symbol to a filled circle
color = "red"      # set the item color
xlim = c(-10,10)   # set limits of the x-axis (horizontal axis)
ylim = c(0,100)    # set limits of the y-axis (vertical axis)
lty = 2            # set line type to dashed
las = 2            # rotate axis labels to be perpendicular to axis
cex = 1.5          # magnify the plotting symbols 1.5-fold
cex.lab = 1.5      # magnify the axis labels 1.5-fold
cex.axis = 1.3     # magnify the axis annotation 1.3-fold
xlab = "Body size" # label for the x-axis
ylab = "Frequency" # label for the y-axis
```

For details and the full list of plotting options in base R, get help as follows,

```{r eval = FALSE}
?par              # graphical parameters
?plot.default     # basic plot decorations
```

<br>

### Drawing graphs with <code>ggplot</code>
Building a graph using <code>ggplot</code>involves the combination of components or "layers" including data, "aesthetics" that map variables to visuals, and "geoms" that create different kinds of plots. A basic scatter plot of <code>yvar</code> against <code>xvar</code> has the three components as follows.

```{r eval = FALSE}
ggplot(data = mydata, mapping = aes(x = xvar, y = yvar)) +
		geom_point() +
		theme_classic()
```

where <code>geom_point()</code> is the specific geom for plotting points. Other graph components can be added, as demonstrated with examples below.

<br>

### Save graph as a pdf file
After drawing your plot, you can use the menu (File -< Save As) to save to a pdf file. Or, draw the graph on a pdf device to begin with:

```{r eval = FALSE}
pdf(file = "mygraph.pdf")     # opens the pdf device for plotting
...                           # Issue your R commands here to generate plot
dev.off()                     # closes the device when you are done
```

***

## Frequency distribution of a variable

### Bar graph
In the following examples, <code>A</code> is a categorical variable identifying groups.

```{r eval = FALSE}
# base R
barplot(table(mydata$A), col = "firebrick", space = 0.2, cex.names = 1.2)

# Using ggplot
ggplot(mydata, aes(x = A)) +
	geom_bar(stat="count")

# ggplot with options:
ggplot(mydata, aes(x = A)) + 
	geom_bar(stat="count", fill = "firebrick") +
	labs(x = "A group", y = "Frequency") +
	theme(text = element_text(size = 15), 
	  axis.text = element_text(size = 12), aspect.ratio = 0.8) +
	theme_classic()
```

R will arrange the categories in alphabetical order by default. Use the <code>factor</code> command to specify a more meaningful order. For example, if the variable A has three groups "a", "b" and "c", and you want "c" to come first, use the following and then redraw your barplot.

```{r eval = FALSE}
A <- factor(mydata$A, levels = c("c","a","b"))
barplot(table(mydata$A), col = "firebrick")
```

To plot the bars in order of decreasing frequency, (a good idea for bar graphs)

```{r eval = FALSE}
# Using base R
barplot(sort(table(mydata$A), decreasing = TRUE), col = "firebrick", space = 0.2)

# Using ggplot
mydata$A_ordered <- factor(mydata$A, 
	levels = names(sort(table(mydata$A), decreasing = TRUE)) )
ggplot(mydata, aes(x = A_ordered)) + 
	geom_bar(stat="count", fill = "firebrick") +
	labs(x = "A group", y = "Frequency") +
	theme(text = element_text(size = 15), 
	  axis.text = element_text(size = 12), aspect.ratio = 0.8) +
	theme_classic()
```

If the frequencies are already tabulated in a data frame named <code>mytab</code>, then modify as follows. <code>A</code> is a variable in <code>mytab</code> that lists each named category exactly once and <code>Freq</code> is a variable containing the corresponding frequency of cases in each category.

```{r eval = FALSE}
mytab <- arrange(mytab, desc(Freq))
barplot(mytab$Freq, names.arg = mytab$A, col = "firebrick")

# or
mytab$A_ordered <- factor(mytab$A, levels = mytab$A[order(mytab$Freq, decreasing = TRUE)] )
ggplot(mytab, aes(x = A_ordered, y = Freq)) + 
	geom_bar(stat="identity", fill = "firebrick") +
	labs(x = "A group", y = "Frequency") +
	theme(text = element_text(size = 15), 
	       axis.text = element_text(size = 12), aspect.ratio = 0.8) +
	theme_classic()
```

<br>

### Histogram
The basic command is

```{r eval = FALSE}
hist(mydata$x, col = "navy", right = FALSE)
```

The <code>col</code> argument sets the color of the bars. The <code>right = FALSE</code> option causes all the histogram intervals, or bins, except the last one to be left-closed. In other words, the value 1 would appear in the interval 1-2 rather than in the interval 0-1, which seems to be the convention (unless 1 is the upper limit of the right-most bin, in which case R puts it in the bin 0-1; use the <code>include.lowest</code> option to control that!).

Use the <code>breaks</code> option to influence the width and number of histogram bins. To set the approximate number of bins to 20, use

```{r eval = FALSE}
hist(mydata$x, breaks = 20, right = FALSE)
```

For finer control of bin number and location, specify the breakpoints. For example, the following command creates a series of bins 1 unit wide between the limits 0 and 6 (make sure all the data fall between these limits or R will complain),

```{r eval = FALSE}
hist(mydata$x, breaks = seq(from=0, to=6, by=1), right = FALSE)
```

Notice that a value of exactly 6, the upper limit of breaks, will appear in the interval 5-6. This behavior is restricted to the rightmost bin. To prevent this from happening, increase the upper limit of the breaks by 1:

```{r eval = FALSE}
hist(mydata$x, breaks = seq(from=0, to=7, by=1), right = FALSE)
```

In <code>ggplot</code>, the barest histogram for a numeric variable <code>x</code> in <code>mydata</code> requires only

```{r eval = FALSE}
ggplot(mydata, aes(x)) + geom_histogram() 
```

The example below improves the graph with a number of options. To see the impact of each option, leave out and rerun.

```{r eval = FALSE}
ggplot(mydata, aes(x)) + 
	geom_histogram(fill = "firebrick", col = "black", binwidth = 0.2, 
		boundary = 0, closed = "left") + 
	labs(x = "The variable x", y = "Frequency") + 
	theme(aspect.ratio = 0.80) +
	theme_classic()
```

To display probability density instead of raw frequencies,

```{r eval = FALSE}
hist(mydata$x, prob = TRUE, right = FALSE)

# in ggplot
ggplot(mydata, aes(x)) +
	geom_histogram(aes(y = ..density..), closed = "left") +
	theme_classic()
```

To superimpose a normal density curve on a histogram, try the following commands. First, 101 evenly spaced points along the <code>x</code> axis, are made between the smallest and largest data value using <code>seq</code>. Then <code>dnorm</code> generates the normal density at each <code>x</code> point, using the mean and standard deviation of the data.

```{r eval = FALSE}
hist(mydata$x, prob = TRUE, right = FALSE)
m <- mean(mydata$x, na.rm = TRUE)
s <- sd(mydata$x, na.rm = TRUE)
xpts <- seq(from = min(mydata$x, na.rm=TRUE), 
            to = max(mydata$x, na.rm = TRUE), length.out = 101)
lines(dnorm(xpts, mean=m, sd=s) ~ xpts, col="red", lwd=2)
```

In <code>ggplot</code>, add a <code>stat_function()</code> to get the same,

```{r eval = FALSE}
ggplot(mydata, aes(x)) + 
	geom_histogram(aes(y = ..density..), closed = "left") + 
	stat_function(fun = dnorm, args = list(mean = mean(mydata$x, na.rm = TRUE), 
     	     	sd = sd(mydata$x, na.rm = TRUE))) +
	theme_classic()
```

<br>

### Normal quantile plot
<code>x</code> is the numeric variable whose distribution is being compared with the normal.

```{r eval = FALSE}
qqnorm(mydata$x)
qqline(mydata$x)  # adds line through first and third quartiles
```

The same can be accomplished in <code>ggplot</code> as follows.

```{r eval = FALSE}
ggplot(mydata, aes(sample = x)) +
	geom_qq() +
	geom_qq_line() +
	theme_classic()
```

***

## Association between variables
The appropriate graph depends on which variables are numeric or categorical.

<br>

### Grouped bar graph
<code>A</code> and <code>B</code> can be factors or character variables in a data frame <code>mydata</code>. The first line of code below is the bare minimum, whereas the second adds a few useful options.

```{r eval = FALSE}
barplot(table(mydata$A, mydata$B), beside = TRUE)

barplot(table(mydata$A, mydata$B), beside = TRUE, 
	las = 1, col = rainbow(4), cex.names = 0.8, space = c(0.2,0.8),
	xlab = "B group", ylab = "Frequency", legend.text = TRUE)
```

With <code>ggplot</code>, use <code>geom_bar(stat="count")</code> and the argument <code>position_dodge2(preserve="single")</code>, which can handle category combinations of <code>A</code> and <code>B</code> having a count of 0.

```{r eval = FALSE}
ggplot(mydata, aes(x = A, fill = B)) + 
	geom_bar(stat = "count", position = position_dodge2(preserve="single")) +
	labs(x = "A group", y = "Frequency") +
	theme(aspect.ratio = 0.80) +
	theme_classic()
```

<br>

### Histograms by group
A plot of multiple histograms is useful for comparing the frequency distribution of a numeric variable between groups. Stack the plots above one another if possible, for best results, and use the same minimum and maximum of <code>x</code>-values on the axis. The code below draws a panel of 3 histograms of <code>x</code>, on top of one another, one for each of three groups (<code>a1</code> - <code>a3</code>) of the categorical variable <code>A</code> in <code>mydata</code>.

A panel of plots is accomplished easily with <code>ggplot</code> or the <code>lattice</code> package (a brief introduction to the lattice package is provided at the bottom of this page). In <code>ggplot</code>, add <code>facet_wrap()</code> to place graphs for different groups on the same page.

```{r eval = FALSE}
ggplot(mydata, aes(x = x)) + 
	geom_histogram(fill = "firebrick", col = "black", binwidth = 0.2, 
		boundary = 0, closed = "left") +
	labs(x = "The variable x", y = "Frequency") + 
	theme(aspect.ratio = 0.5) + 
	facet_wrap( ~ A, ncol = 1, scales = "free_y") +
	theme_classic()
```

To accomplish the task in base R, begin by setting up a graphics window with the desired number of rows and columns (here, 3 and 1, respectively) using the <code>mfrow</code> option of <code>par()</code>. Here the <code>mar</code> option is used to adjust the size of the margin around each plot, and <code>cex</code> is used to reduce the font size of labels to make room. The following code loops through the three unique categories of <code>A</code> and draws a histogram for <code>x</code> for each group.

```{r eval = FALSE}
par(mfrow=c(3,1), mar = c(4, 4, 2, 1), cex = 0.7) 
for( i in unique(mydata$A) ){
	dat <- subset(mydata, mydata$A == i)
	hist(dat$x, breaks = 20, right = FALSE, xlim = range(mydata$x), 
		col="firebrick", main = i, xlab = "x variable", ylab = "Frequency")
	}
```

<br>

### Mosaic plot
A and B can be factors or character variables. <code>color = TRUE</code> yields shades of grey, or a vector of colors can be used instead (shown below for 3 categories). A quick way to get a bunch of different colors is to use <code>color = rainbow(n)</code>, where <code>n</code> is the number of categories for the variable B. Other options in the examples below alter the orientation (<code>las</code>) and size (<code>cex.axis</code>) of the labels.

```{r eval = FALSE}
mosaicplot(table(mydata$A, mydata$B), color = c("red","blue","yellow"), 
           las = 2, cex.axis = 0.8)
```

To draw a mosaic plot using <code>ggplot</code>, first install the <code>ggmosaic</code> package. The example below loads the package, assuming it is installed.

```{r eval = FALSE}
library(ggmosaic)
ggplot(mydata) + 
	geom_mosaic(aes(x = product(A, B), fill=factor(A))) +
	labs(x = "B group") + 
	theme(aspect.ratio = 1, 
	      axis.text.x = element_text(angle = -25, hjust= .1, size = 12)) + 
	guides(fill = guide_legend(title = "A group", reverse = TRUE)) +
	theme_classic()
```

<br>

### Strip chart
A strip chart (a.k.a dot plot) can be used instead of a box plot when the number of data points is not large. Random noise ("jitter") is used to reduce overlap of points. The first example is a basic plot, whereas the second adds common options.

```{r eval = FALSE}
# base R
stripchart(y ~ A, vertical = TRUE, data = mydata, method = "jitter")

stripchart(y ~ A, vertical = TRUE, data = mydata, method = "jitter", 
	jitter = 0.2, cex.axis = 0.8, pch = 1, col = "firebrick")
```

The first line of code below shows the basic strip chart with <code>ggplot()</code>. The second example includes common options.

```{r eval = FALSE}
ggplot(mydata, aes(A, y)) + geom_jitter()

ggplot(mydata, aes(A, y)) +
	geom_jitter(color = "firebrick", size = 3, width = 0.15) +
	labs(x = "A group", y = "y value") + 
	theme(aspect.ratio = 0.80, text = element_text(size = 12), 
	      axis.text = element_text(size = 10)) +
	theme_classic()
```

<br>

### Strip chart with error bars

Use ```stat_summary()``` to overlay mean and standard error bars. Use ```fun.data = mean_cl_normal``` to get 95% confidence intervals instead of standard error bars. Shift the position of the error bars using ```position_nudge()``` to eliminate overlap with the raw data.

```{r eval = FALSE}
ggplot(mydata, aes(A, y)) +
	geom_jitter(color = "firebrick", size = 3, width = 0.15) +
  stat_summary(fun.data = mean_se, geom = "errorbar", 
        width = 0.1, position=position_nudge(x = 0.2)) +
  stat_summary(fun.y = mean, geom = "point", 
        size = 3, position=position_nudge(x = 0.2)) +
	labs(x = "A group", y = "y value") + 
	theme(aspect.ratio = 0.80, text = element_text(size = 12), 
	      axis.text = element_text(size = 10)) +
	theme_classic()
```

You can add points or lines to a base R <code>stripchart</code> by using integer numbers to indicate position of categories along the x-axis. For example, to add means and standard errors of <code>y</code> to a strip chart for a numeric variable <code>y</code> and a categorical variable <code>A</code> having four categories, use

```{r eval = FALSE}
stripchart(y ~ A, data = mydata, vertical = TRUE, method = "jitter", pch = 1)
m <- tapply(mydata$y, mydata$A, mean, na.rm=TRUE)
se <- tapply(mydata$y, mydata$A, 
          function(y){ sd(y, na.rm=TRUE)/sqrt(length(na.omit(y))) })
points( m ~ c(1:4 + 0.2) + 0.2, pch=16, col = "red")
segments(x0 = c(1:4 + 0.2), y0 = m - se, 
          x1 = c(1:4 + 0.2), y1 = m + se, col = "red")
```

<br>

### Strip chart for paired data
Paired data should be displayed accordingly. The following commands create a strip chart with lines connection the two measurements of the same unit in the two treatments. The data frame <code>mydata</code> includes the response variable <code>y</code>, the treatment variable <code>A</code>, and an <code>id</code> variable indicating identity of individuals measured under both treatments.

The following works in base R.

```{r eval = FALSE}
interaction.plot(response = mydata$y, x.factor = mydata$A, trace.factor = mydata$id,
	legend = FALSE, lty = 1, xlab = "Treatment", ylab = "Y variable", 
	type = "b", pch = 16, las = 1, cex = 1.5, cex.lab = 1.5, cex.axis = 1.3)
```

<img class="imgb" title="paired" src="images/paired data strip chart baseR.jpg" alt="" width="300" height="300">

Try the following with <code>ggplot</code>.

```{r eval = FALSE}
ggplot(mydata, aes(y = y, x = A)) +  
	geom_point(size = 5, col = "firebrick", alpha = 0.5) + 
	geom_line(aes(group = id)) +
	labs(x = "Treatment", y = "Y variable") + 
	theme(text = element_text(size = 18), 
	      axis.text = element_text(size = 16), aspect.ratio = 0.80) +
	theme_classic()
```

<img class="imgb" title="paired" src="images/paired data strip chart ggplot.jpg" alt="" width="300" height="300">

<br>

### Strip charts by group
A grouped strip chart displays a numeric response variable <code>y</code> for different levels of two categorical variables, <code>A</code> and <code>B</code>. This can be accomplished in base R by overlaying multiple strip charts, but it is much easier to produce the plot in <code>ggplot</code>.

```{r eval = FALSE}
ggplot(data = mydata, aes(y = y, x = A, fill = B, color = B)) + 
	geom_jitter(size = 3, position = position_dodge(width = 0.7)) +
	labs(x = "A variable", y = "y variable") +
	theme(aspect.ratio = 0.75, text = element_text(size = 16), 
	      axis.text = element_text(size = 14)) +
	theme_classic()
```

<code>position_dodge(width = )</code> controls the horizontal distance between the adjacent strips depicting different levels of the <code>B</code> variable within each group defined by the <code>A</code> variable.

<img class="imgb" title="groupstrip" src="images/groupstrip ggplot.jpg" alt="" width="300" height="300">

<br>

### Box plot
The following code generates a box plot for the numeric variable <code>yvar</code> separately for every group identified in the categorical variable <code>A</code>. The following shows use of the formula method in <code>barplot</code>, written as "response_variable ~ explanatory_variable". Set <code>varwidth = FALSE</code> if you want all boxes to have the same width.

```{r eval = FALSE}
boxplot(yvar ~ A, data = mydata, varwidth = TRUE, 
	ylab="y value", col = "firebrick", cex.axis = 0.8)
```

The next command shows how to make a basic box plot with <code>ggplot</code>. Below it is a command with more options.

```{r eval = FALSE}
ggplot(mydata, aes(x = A, y = yvar)) +
	geom_boxplot()

ggplot(mydata, aes(x = A, y = yvar)) + 
	geom_boxplot(fill = "firebrick", notch = FALSE, varwidth = TRUE) + 
	labs(x = "A group", y = "y value") + 
	theme(text = element_text(size = 15), axis.text = element_text(size = 12), 
	      aspect.ratio = 0.80) +
	theme_classic()
```

<br>

### Box plots by group
A grouped box plot displays a numeric response variable <code>y</code> for different levels of two categorical variables, <code>A</code> and <code>B</code>. This can be accomplished in base R by overlaying multiple box plots, but it is much easier to produce the plot in <code>ggplot</code>.

```{r eval = FALSE}
ggplot(data = mydata, aes(y = y, x = A, fill = B)) + 
	geom_boxplot(width = 0.6, position = position_dodge(width = 0.7)) +
	labs(x = "A variable", y = "y variable") +
	theme(aspect.ratio = 0.75, text = element_text(size = 16), 
	      axis.text = element_text(size = 14)) +
	theme_classic()
```

<code>width</code> controls the width of each box, whereas <code>position_dodge(width = )</code> controls the horizontal distance between the adjacent boxes depicting different levels of the <code>B</code> variable within each group defined by the <code>A</code> variable.

<img class="imgb" title="groupbox" src="images/groupbox ggplot.jpg" alt="" width="300" height="300">

<br>

### Violin plot
A violin plot shows the frequency distribution for a numerical variable (and its mirror image) for several groups. The frequency distribution is a kernel density estimate, which "smooths" the distribution. The following code generates a violin plot for the numeric variable <code>yvar</code> separately for every group identified in the categorical variable <code>A</code>. This is easiest to accomplish in <code>ggplot</code>. The <code>stat_summary</code> layer adds a dot for the mean of each group.

```{r eval = FALSE}
ggplot(mydata, aes(x = A, y = yvar)) + 
	geom_violin(fill = "firebrick") + 
	stat_summary(fun.y = mean,  geom = "point", color = "black") +
	labs(x = "A group", y = "y value") + 
	theme(text = element_text(size = 15), axis.text = element_text(size = 12), 
	      aspect.ratio = 0.80) +
	theme_classic()
```

The job is possible without <code>ggplot</code>, but you'll need to install the <code>vioplot</code> package first using <code>install.packages()</code>, and then load it. Here, <code>yvar</code> is the variable plotted separately for groups of the variable <code>A</code>. In this example, A has 4 groups named <code>a1</code>, <code>a2</code>, <code>a3</code>, and <code>a4</code>. The amount of "smoothing" for the kernel density estimates is controlled by the <code>h</code> option.

```{r eval = FALSE}
library(vioplot)
vioplot(mydata$yvar[mydata$A=="a1"], mydata$yvar[mydata$A=="a2"], 
	mydata$yvar[mydata$A=="a3"], mydata$yvar[mydata$A=="a4"],
	col="#FFB531", drawRect = FALSE, names = c("a1","a2","a3","a4"),
	h = 0.5)
mtext("y value", side=2, line=2, las = 3)
mtext("A group", side=1, line = 3)
```

<br>

### Scatter plot
Here's how to to produce a scatter plot for two numeric variables, <code>x</code> and <code>y</code>.

```{r eval = FALSE}
# formula method, base R
plot(y ~ x, data = mydata, pch = 16, col = 2)

# basic scatter plot in ggplot
ggplot(mydata, aes(x, y)) + geom_point()

# scatter plot with options in ggplot
ggplot(mydata, aes(x, y)) + 
	geom_point(size = 2, col = "firebrick", alpha = 0.5) + 
	labs(x = "x variable", y = "y variable") + 
	theme(aspect.ratio = 0.80) +
	theme_classic()
```

You can probably guess the intent of most of the <code>ggplot</code> options except <code>alpha</code>, which makes the dots partly transparent.

To add a smooth curve through the data, use locally weighted regression. "Local" here means that <code>y</code> is predicted for each <code>x</code> using only data in the vicinity of that <code>x</code>, rather than all the data.

In base R you can control the size of the vicinity using the option <code>f</code>, which is a proportion between 0 (very narrow vicinity) and 1 (uses all the data). Try different values of <code>f</code> to best capture the relationship. The default is <code>f = 2/3</code>.

```{r eval = FALSE}
plot(y ~ x, data = mydata)
x1 <- mydata$x[order(mydata$x)]
y1 <- mydata$y[order(mydata$x)]
lines(lowess(mydata$x1, mydata$y1, f = 0.5))
```

Using <code>ggplot</code>, you also get SE's of predicted values (set to FALSE if not desired).

```{r eval = FALSE}
ggplot(mydata, aes(x, y)) + 
	geom_point(size = 2, col = "firebrick") + 
	labs(x = "x variable", y = "y variable") + 
   	geom_smooth(method = "loess", size = 1, col = "black", se = TRUE) +
	theme(aspect.ratio = 0.80) +
	theme_classic()
```

To add the least squares regression line to a plot, use the following.

```{r eval = FALSE}
plot(y ~ x, data = mydata)
abline(lm(y ~ x, data = mydata))

# in ggplot
ggplot(mydata, aes(x, y)) + 
	geom_point(size = 2, col = "firebrick") + 
	labs(x = "x variable", y = "y variable") + 
   	geom_smooth(method = "lm", size = 1, col = "black") +
	theme(aspect.ratio = 0.80) +
	theme_classic()
```

In base R you can use the cursor to click data points to identify individuals. The following code prints the row number when you click a point (change that by setting the <code>labels</code> option to a character variable that labels the point instead).

```{r eval = FALSE}
plot(y ~ x, data = mydata)
identify(mydata$x, mydata$y, labels = seq_along(mydata$x))
```

<br>

### Scatter plots by group
One way to make a scatter plot for multiple groups is to superimpose them all on a single plot but vary the symbols according to group. In base R, use <code>pch</code> to vary the symbol, <code>col</code> to vary the color, and both to vary both at the same time. <code>x</code> and <code>y</code> are numeric variables, whereas <code>A</code> is a categorical variable identifying groups. If <code>A</code> is already a factor you can use just <code>A</code> instead of <code>factor(A)</code> in the commands below. The <code>legend</code> command adds a legend identifying the groups---click on the plot (inside the plot region) with your cursor to place the legend.

```{r eval = FALSE}
plot(y ~ x, data = mydata, pch = as.numeric(factor(mydata$A)),
         col = as.numeric(factor(mydata$A)))
legend( locator(1), legend = as.character(levels(factor(mydata$A))), 
	pch = 1:length(levels(factor(mydata$A))), 
	col=1:length(levels(factor(mydata$A))) )
```

To accomplish the same with <code>ggplot</code>, specify which variable to vary by color and by shape within <code>aes()</code>, which maps variables to visuals. The example below includes an optional <code>geom_smooth()</code> line that will result in the least squares lines for each group also superimposed.

```{r eval = FALSE}
ggplot(mydata, aes(x, y, colour = A, shape = A)) + 
	geom_point(size = 2) + 
	geom_smooth(method = "lm", size = 1, se = FALSE) +
	labs(x = "x variable", y = "y variable") + 
	theme(aspect.ratio = 0.80) +
	theme_classic()
```

Another way to make a scatter plot for multiple groups is to plot them separately in panes of a panel of plots. Use <code>facet_wrap</code>() in <code>ggplot</code> for this purpose, as follows. The <code>lattice</code> package can also be used to make panels of plots, as described briefly at the bottom of the page.

```{r eval = FALSE}
ggplot(mydata, aes(x, y)) + 
	facet_wrap(~A, ncol = 2) + 
	geom_point(col = "firebrick", size = 2) +
   	geom_smooth(method = "lm", size = 1, se = FALSE, col = "black") +
	labs(x = "x variable", y = "y variable") + 
	theme(aspect.ratio = 0.80) +
	theme_classic()
```

<br>

### Pairwise scatter plots
The following command creates a single graph with scatter plots between all pairs of numeric variables in a data frame, <code>mydata</code>. The option <code>gap</code> adjusts the spacing between separate plots,

```{r eval = FALSE}
pairs(mydata, gap = 0.5)
```

Use the formula method to plot only the three numeric variables x1, x2, and x3 in the data frame mydata.

```{r eval = FALSE}
pairs(~ x1 + x2 + x3, data = mydata)
```

<br>

### Line plot
Here's how to plot a sequence of (<code>x, y</code>) points and connect the dots with lines. This is especially useful when the <code>x</code>-variable represents a series of points in time or across a spatial gradient. In base R:

```{r eval = FALSE}
plot(y ~ x, data = mydata, pch=16)
lines(y[order(x)] ~ x[order(x)], data = mydata)

# Eliminate the points, and some options
plot(y[order(x)] ~ x[order(x)], data = mydata, type = "l", 
	lty = 3, lwd = 2, col = "red")
```

The basic <code>ggplot</code> command is below. There's no need to order by <code>x</code>.

```{r eval = FALSE}
ggplot(data = mydata, aes(x, y)) +
	geom_line()
```

A line plot in <code>ggplot</code> works if the explanatory variable is numeric (<code>x</code>) or categorical (<code>A</code>), as show in the two commands below (which also include further options).

```{r eval = FALSE}
ggplot(data = mydata, aes(x, y)) +
	geom_line(color = "red") +
	geom_point() +
	labs(x = "x variable", y = "y variable") + 
	theme(text = element_text(size = 15), 
		axis.text = element_text(size = 12), aspect.ratio = 0.75) +
	theme_classic()

# To use categorical variable A, include "group = 1" in aes()
ggplot(data = mydata, aes(A, y, group = 1)) +
	geom_line(color = "red") +
	geom_point() +
	labs(x = "A variable", y = "y variable") + 
	theme(text = element_text(size = 15), 
		axis.text = element_text(size = 12), aspect.ratio = 0.75) +
	theme_classic()
```

### Interaction plots
The command <code>interaction.plot</code> is quick but rudimentary, as it fails to show the data.

Interaction plots display how the mean of a numeric response variable <code>y</code> changes between the levels of two categorical variables, <code>A</code> and <code>B</code>. The graph is especially useful for determine whether an interaction is present between two factors <code>A</code> and <code>B</code> in a factorial experiment, or between a factor <code>A</code> and a blocking variable <code>B</code>. If the lines are parallel then there is no interaction.

```{r eval = FALSE}
interaction.plot(A, B, y)
```

The levels of the variable listed first (here, <code>A</code>) will be displayed along the x-axis of the plot. The y-axis will then display the mean of y separately for each category of the second variable, <code>B</code>.  Variations on this command include

```{r eval = FALSE}
# Put B along x-axis instead
interaction.plot(mydata$B, mydata$A, mydata$y)

# Plot the median of y
interaction.plot(mydata$A, mydata$B, mydata$y, fun = median)

# Color the lines
interaction.plot(mydata$A, mydata$B, mydata$y, 
        col = 1:length(unique(mydata$B)))

# More room for A's labels
interaction.plot(mydata$A, mydata$B, mydata$y, las=2)
```

***

## Using the <code>lattice</code> package
The <code>lattice</code> package makes it easy to draw a panel of plots separately by group. The basic plot is simple, but commands to add points and lines to the individual panes can be tricky.

The <code>lattice</code> package is included with the basic installation but you need to load the library. The graph types available in the lattice package include the standard ones found also in R's basic graphics package, such as box plots, histograms, and so on. The table below lists the most types and the relevant command.

For example, to draw a histogram of a numeric variable <code>x</code> separately for four groups identified by the variable <code>B</code> in the data frame <code>mydata</code>, use

```{r eval = FALSE}
library(lattice)
histogram(~ x | B, data = mydata, layout = c(1,4), right = FALSE)
```

The <code>layout</code> option is special to lattice and draws the 4 panels in a grid with 1 column with 4 rows, so that the histograms are stacked and most easily compared visually. The <code>right=FALSE</code> option has the same meaning here as for the base R <code>hist</code> command.

To draw a bar graph showing the frequency distribution of a categorical variable <code>A</code> separately for each group identified by the variable <code>B</code>,

```{r eval = FALSE}
barchart( ~ table(A) | B, data = mydata)
```

This produces horizontal bar graphs, which leaves room for the category labels. To draw the bars vertically instead, while tilting the group labels on the x-axis by 45 degrees so that they fit,

```{r eval = FALSE}
barchart(table(A) ~ names(table(A)) | B, data = mydata, 
         scales = list(x=list(rot=45)))
```

As a third example, draw a scatter plot to show the relationship between the numeric variables <code>x</code> and <code>x</code> separately for each group in the variable <code>B</code>. The <code>pch</code> option in this example replaces the default plot symbol with a filled dot, and the <code>aspect</code> option sets the relative lengths of the vertical and horizontal axes.

```{r eval = FALSE}
xyplot(y ~ x | B, data = mydata, pch = 16, aspect = 0.7)
```

It is possible to add plot elements to individual panels, but the commands and options take some getting used to. For example, to fit a separate regression line to each scatter plot, one to each group, use the <code>panel</code> argument in <code>xyplot</code> to construct a function that applies built-in panel functions to each group, as follows.

```{r eval = FALSE}
xyplot(y ~ x | B, data = mydata, pch = 16, aspect = 0.7,
	panel=function(x, y){       # Use x and y here, not real variable names
		panel.xyplot(x, y)  # draws the scatter plot
		panel.lmline(x, y)  # fits the regression line
		}
	)
```

This doesn't even begin to describe what's possible using the lattice package. Crawley has a few more examples of trellis graphics in <i>The R Book</i>. Sarkar (2008) gives a complete description. See the links to these books on the "Books" tab of the Biology 501 course page.

The table below shows a few of the commonly used plotting commands in the lattice package. <code>x</code> and <code>y</code> are numeric variables, whereas <code>A</code> is a categorical variable (character or factor). <code>B</code> is a factor or character variable that will define the groups or subsets of the data frame to be plotted in separate panels. A separate plot in the graphics window will be made for each of the groups defined by the variable <code>B</code>.

<style type="text/css">
.tg td{font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#000000;color:#.tg  {border-collapse:collapse;border-spacing:0;border-color:#000000;}
;background-color:##5c7eb8;}
.tg .tg-0lax{text-align:left;vertical-align:top}
</style>
<table class="tg">
  <tr>
    <td class="tg-0lax">**Command**</td>
    <td class="tg-0lax">**Graph type**</td>
    <td class="tg-0lax">**Syntax (~ is the "tilde" symbol)**</td>
  </tr>
  <tr>
    <td class="tg-0lax"><code>barchart</code></td>
    <td class="tg-0lax">bar graph</td>
    <td class="tg-0lax"><code>barchart(~table(A) | B, data=mydata)</code></td>
  </tr>
  <tr>
    <td class="tg-0lax"><code>bwplot</code></td>
    <td class="tg-0lax">box plot</td>
    <td class="tg-0lax"><code>bwplot(x ~ A | B, data=mydata)</code></td>
  </tr>
  <tr>
    <td class="tg-0lax"><code>histogram</code></td>
    <td class="tg-0lax">histogram</td>
    <td class="tg-0lax"><code>histogram(~x | B, data=mydata, right=FALSE)</code></td>
  </tr>
  <tr>
    <td class="tg-0lax"><code>stripplot</code></td>
    <td class="tg-0lax">strip chart</td>
    <td class="tg-0lax"><code>stripplot(x ~ A | B, data=mydata, jitter=TRUE)</code></td>
  </tr>
  <tr>
    <td class="tg-0lax"><code>xyplot</td>
    <td class="tg-0lax">scatter plot</td>
    <td class="tg-0lax"><code>xyplot(y ~ x | B, data=mydata)</code></td>
  </tr>
</table>
